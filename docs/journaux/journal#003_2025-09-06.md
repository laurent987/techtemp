# Journal #003 ‚Äî Base SQLite + Config (2025-09-06)

## Objectif

Impl√©menter l'**infrastructure de donn√©es de base** pour le service-app :
- Configuration environment (via variables d'environnement)
- Initialisation SQLite avec sch√©ma contractuel
- Repository pattern pour acc√®s aux donn√©es
- Tests d'int√©gration SQLite

## Contexte

Journal #002 a livr√© le client MQTT robuste. Maintenant il faut la **fondation base de donn√©es** pour pouvoir stocker les lectures des capteurs selon le contrat 001.

## D√©cisions

- **SQLite** avec mode WAL activ√© pour les performances
- **better-sqlite3** comme driver (synchrone, performant)
- **Configuration via process.env** avec validation Joi
- **Migrations automatiques** au d√©marrage (fonction `migrateIfNeeded()`)
- **Architecture en couches** : Repository (m√©tier) + Data Access (SQL) + Database (connexion)
- **Repository pattern correct** : logique m√©tier sans SQL direct
- Tests avec **base temporaire** (`:memory:` ou fichier temp)

## Port√©e (Scope)

### ‚úÖ √Ä impl√©menter
- `src/config.js` : `loadConfig()` avec validation Joi des variables d'environnement
- `src/db/index.js` : 
  - `initDb(dbPath)` ‚Üí ouvre connexion + WAL + foreign_keys  
  - `closeDb()` ‚Üí fermeture propre
- `src/db/dataAccess.js` :
  - Couche d'acc√®s aux donn√©es avec SQL sp√©cifique
  - `insertDevice()`, `insertReading()`, `findLatestReading()`, etc.
- `src/repositories/deviceRepository.js` :
  - Logique m√©tier pure (validation, transformation)
  - D√©l√©gation vers Data Access (pas de SQL direct)
- **Sch√©ma SQLite** selon contrat 001 :
  - Tables : `rooms`, `devices`, `device_room_placements`, `readings_raw`
  - Vues : `v_room_last`
  - Index appropri√©s
- **Tests d'int√©gration** :
  - Configuration loading/validation
  - Database creation + schema migration
  - Repository avec mocks de Data Access
  - Data Access avec vraie base temporaire
  - Fermeture propre (pas de handles ouverts)

### ‚ùå Hors Port√©e
- Pipeline d'ingestion MQTT ‚Üí DB (Journal #004)
- Serveur HTTP (Journal #005)
- API endpoints (Journal #006)
- Gestion des erreurs MQTT en production

## Plan d'impl√©mentation

### Phase 1: Configuration
- [ ] √âcrire `test/config.test.js` avec cas de test :
  - Configuration valide avec toutes les variables
  - Variables manquantes ‚Üí erreur explicite
  - Variables invalides ‚Üí erreur avec d√©tails
  - Valeurs par d√©faut (ex: `TOPIC_READING_PATTERN`)
- [ ] Impl√©menter `loadConfig()` pour faire passer les tests
- [ ] Validation Joi avec sch√©ma d√©taill√©

### Phase 2: Base SQLite
- [ ] √âcrire `test/db.test.js` avec cas de test :
  - Cr√©ation base + sch√©ma complet
  - Pragmas WAL + foreign_keys appliqu√©s
  - Migration idempotente (relancer n'ajoute rien)
  - Fermeture propre sans leaks
- [ ] Impl√©menter `initDb(dbPath)` et `closeDb()`
- [ ] Impl√©menter le sch√©ma selon contrat 001

### Phase 3: Data Access 
- [ ] √âcrire `test/dataAccess.test.js` avec cas de test :
  - CRUD operations sur chaque table
  - Contraintes de cl√©s √©trang√®res respect√©es
  - Requ√™tes complexes (jointures, agr√©gations)
  - Gestion d'erreurs SQL
- [ ] Impl√©menter `createDataAccess(db)` avec m√©thodes SQL
- [ ] V√©rifier performance avec base temporaire

### Phase 4: Repository 
- [ ] √âcrire `test/repositories.test.js` avec cas de test :
  - Logique m√©tier pure (validation, transformation)
  - D√©l√©gation correcte vers Data Access  
  - Gestion d'erreurs m√©tier
  - Mocks de Data Access (pas de vraie DB)
- [ ] Impl√©menter `createDeviceRepository(dataAccess)`
- [ ] Tests d'int√©gration Repository + Data Access + DB

## Artifacts attendus

- `service-app/src/config.js` (impl√©mentation compl√®te)
- `service-app/src/db/index.js` (connexion + migrations)
- `service-app/src/db/dataAccess.js` (couche SQL)
- `service-app/src/repositories/deviceRepository.js` (logique m√©tier)
- `service-app/test/config.test.js` (tests unitaires config)
- `service-app/test/db.test.js` (tests d'int√©gration DB)
- `service-app/test/repositories.test.js` (tests avec mocks)
- Mise √† jour `package.json` si nouvelles d√©pendances

## Crit√®res d'acceptation

‚úÖ **Config** : `loadConfig()` parse et valide les variables d'environnement  
‚úÖ **SQLite** : `initDb()` cr√©e la base avec sch√©ma complet et pragmas  
‚úÖ **Data Access** : Couche SQL avec m√©thodes CRUD sur toutes les tables  
‚úÖ **Repository** : Logique m√©tier pure sans SQL direct  
‚úÖ **Tests** : Tous les tests passent, pas de ressources qui fuient  
‚úÖ **Contrat** : Schema DB conforme exactement au contrat 001  

## Commandes pr√©vues

```bash
# Nouvelles d√©pendances
npm install better-sqlite3 joi

# Tests
npm run test -- db config

# V√©rification sch√©ma (manuel)
sqlite3 test.db ".schema"
```

## Liens utiles

- **Contrat 001** : `docs/contrats/001-base-service-app.md` (section 2 - SQLite)
- **Repository pattern** : logique m√©tier s√©par√©e de l'acc√®s donn√©es
- **Data Access Layer** : couche SQL sp√©cialis√©e par type de base
- **better-sqlite3 docs** : https://github.com/WiseLibs/better-sqlite3
- **Joi validation** : https://joi.dev/api/

---

üìù **Architecture en couches** :
```
Business Logic ‚Üí Repository (m√©tier) ‚Üí Data Access (SQL) ‚Üí Database (connexion)
```

üìù **Next** : Journal #004 ‚Äî Pipeline d'ingestion MQTT ‚Üí SQLite
