# Journal #003 — Base SQLite + Config (2025-09-06)

## Objectif

Implémenter l'**infrastructure de données de base** pour le service-app :
- Configuration environment (via variables d'environnement)
- Initialisation SQLite avec schéma contractuel
- Repository pattern pour accès aux données
- Tests d'intégration SQLite

## Contexte

Journal #002 a livré le client MQTT robuste. Maintenant il faut la **fondation base de données** pour pouvoir stocker les lectures des capteurs selon le contrat 001.

## Décisions

- **SQLite** avec mode WAL activé pour les performances
- **better-sqlite3** comme driver (synchrone, performant)
- **Configuration via process.env** avec validation Joi
- **Migrations automatiques** au démarrage (fonction `migrateIfNeeded()`)
- **Architecture en couches** : Repository (métier) + Data Access (SQL) + Database (connexion)
- **Repository pattern correct** : logique métier sans SQL direct
- Tests avec **base temporaire** (`:memory:` ou fichier temp)

## Portée (Scope)

### ✅ À implémenter
- `src/config.js` : `loadConfig()` avec validation Joi des variables d'environnement
- `src/db/index.js` : 
  - `initDb(dbPath)` → ouvre connexion + WAL + foreign_keys  
  - `closeDb()` → fermeture propre
- `src/db/dataAccess.js` :
  - Couche d'accès aux données avec SQL spécifique
  - `insertDevice()`, `insertReading()`, `findLatestReading()`, etc.
- `src/repositories/deviceRepository.js` :
  - Logique métier pure (validation, transformation)
  - Délégation vers Data Access (pas de SQL direct)
- **Schéma SQLite** selon contrat 001 :
  - Tables : `rooms`, `devices`, `device_room_placements`, `readings_raw`
  - Vues : `v_room_last`
  - Index appropriés
- **Tests d'intégration** :
  - Configuration loading/validation
  - Database creation + schema migration
  - Repository avec mocks de Data Access
  - Data Access avec vraie base temporaire
  - Fermeture propre (pas de handles ouverts)

### ❌ Hors Portée
- Pipeline d'ingestion MQTT → DB (Journal #004)
- Serveur HTTP (Journal #005)
- API endpoints (Journal #006)
- Gestion des erreurs MQTT en production

## Plan d'implémentation

### Phase 1: Configuration
- [x] Écrire `test/config.test.js` avec cas de test :
  - Configuration valide avec toutes les variables
  - Variables manquantes → erreur explicite
  - Variables invalides → erreur avec détails
  - Valeurs par défaut (ex: `TOPIC_READING_PATTERN`)
- [x] Implémenter `loadConfig()` pour faire passer les tests
- [x] Validation Joi avec schéma détaillé

### Phase 2: Base SQLite
- [x] Écrire `test/db.test.js` avec cas de test :
  - Création base + schéma complet
  - Pragmas WAL + foreign_keys appliqués
  - Migration idempotente (relancer n'ajoute rien)
  - Fermeture propre sans leaks
- [x] Implémenter `initDb(dbPath)` et `closeDb()`
- [x] Implémenter le schéma selon contrat 001

### Phase 3: Data Access 
- [x] Écrire `test/dataAccess.test.js` avec cas de test :
  - CRUD operations sur chaque table
  - Contraintes de clés étrangères respectées
  - Requêtes complexes (jointures, agrégations)
  - Gestion d'erreurs SQL
- [x] Implémenter `createDataAccess(db)` avec méthodes SQL
- [x] Vérifier performance avec base temporaire

### Phase 4: Repository 
- [x] Écrire `test/repositories.test.js` avec cas de test :
  - Logique métier pure (validation, transformation)
  - Délégation correcte vers Data Access  
  - Gestion d'erreurs métier
  - Mocks de Data Access (pas de vraie DB)
- [x] Implémenter `createDeviceRepository(dataAccess)`
- [x] Tests d'intégration Repository + Data Access + DB

## Artifacts attendus

- `service-app/src/config.js` (implémentation complète)
- `service-app/src/db/index.js` (connexion + migrations)
- `service-app/src/db/dataAccess.js` (couche SQL)
- `service-app/src/repositories/deviceRepository.js` (logique métier)
- `service-app/test/config.test.js` (tests unitaires config)
- `service-app/test/db.test.js` (tests d'intégration DB)
- `service-app/test/repositories.test.js` (tests avec mocks)
- Mise à jour `package.json` si nouvelles dépendances

## Critères d'acceptation

✅ **Config** : `loadConfig()` parse et valide les variables d'environnement  
✅ **SQLite** : `initDb()` crée la base avec schéma complet et pragmas  
✅ **Data Access** : Couche SQL avec méthodes CRUD sur toutes les tables  
✅ **Repository** : Logique métier pure sans SQL direct  
✅ **Tests** : Tous les tests passent (71/71), pas de ressources qui fuient  
✅ **Contrat** : Schema DB conforme exactement au contrat 001  
✅ **Bonus** : Colonnes explicites (temperature/humidity) + Démos fonctionnelles  

## Commandes prévues

```bash
# Nouvelles dépendances
npm install better-sqlite3 joi

# Tests
npm run test -- db config

# Vérification schéma (manuel)
sqlite3 test.db ".schema"
```

## Liens utiles

- **Contrat 001** : `docs/contrats/001-base-service-app.md` (section 2 - SQLite)
- **Repository pattern** : logique métier séparée de l'accès données
- **Data Access Layer** : couche SQL spécialisée par type de base
- **better-sqlite3 docs** : https://github.com/WiseLibs/better-sqlite3
- **Joi validation** : https://joi.dev/api/

---

📝 **Architecture en couches** :
```
Business Logic → Repository (métier) → Data Access (SQL) → Database (connexion)
```

📝 **Next** : Journal #004 — Pipeline d'ingestion MQTT → SQLite

---

## 🎉 BILAN FINAL — Journal #003 ACCOMPLI (7 septembre 2025)

### ✅ **STATUT : COMPLET**
**71 tests passent** • **Toutes les phases réalisées** • **Objectifs dépassés**

### 📊 **RÉALISATIONS**

**Phase 1 - Configuration** ✅
- `src/config.js` : Validation Joi complète avec schéma détaillé
- `test/config.test.js` : 15 tests couvrant tous les cas d'erreur
- Support des variables optionnelles (MQTT_USERNAME, MQTT_PASSWORD)
- Validation stricte des ports et URLs

**Phase 2 - Base SQLite** ✅  
- `src/db/index.js` : Initialisation avec WAL + foreign_keys
- `test/db.test.js` : 8 tests d'intégration base + schéma
- Schéma complet selon contrat 001 avec **colonnes explicites**
- Migrations idempotentes et fermeture propre

**Phase 3 - Data Access** ✅
- `src/db/dataAccess.js` : Couche SQL avec CRUD sur toutes les tables
- `test/dataAccess.test.js` : 8 tests avec contraintes et jointures
- Requêtes optimisées avec préparation et réutilisation
- Gestion d'erreurs SQL robuste

**Phase 4 - Repository** ✅
- `src/repositories/index.js` : Logique métier pure sans SQL
- `test/repositories.test.js` : 26 tests avec validation business
- Pattern Repository correct avec délégation Data Access
- Validation des ranges (température -50°C/100°C, humidité 0%/100%)

### 🚀 **BONUS ACCOMPLIS**
- **Colonnes explicites** : `temperature`/`humidity` au lieu de `t`/`h` 
- **Démos fonctionnelles** : Quick demo + Service complet avec MQTT réel
- **Base organisée** : `examples/db-example/` (pas de pollution racine)
- **Exploration intégrée** : Inspection de base directement dans la démo
- **Tests MQTT** : 14 tests avec broker Aedes intégré

### 📁 **ARTIFACTS LIVRÉS**
```
service-app/
├── src/
│   ├── config.js                    ✅ (62 lignes)
│   ├── db/
│   │   ├── index.js                 ✅ (134 lignes) 
│   │   └── dataAccess.js            ✅ (140 lignes)
│   └── repositories/
│       └── index.js                 ✅ (167 lignes)
├── test/
│   ├── config.test.js               ✅ (15 tests)
│   ├── db.test.js                   ✅ (8 tests)  
│   ├── dataAccess.test.js           ✅ (8 tests)
│   ├── repositories.test.js         ✅ (26 tests)
│   └── mqtt.client.test.js          ✅ (14 tests)
└── examples/
    ├── quick-demo.js                ✅ Demo simple
    ├── service-complete-demo.js     ✅ Demo MQTT réel
    └── db-example/                  ✅ Organisation propre
```

### 💾 **ÉTAT TECHNIQUE**
- **71/71 tests** passent (100% succès)
- **4 dépendances** : better-sqlite3, joi, mqtt, aedes/vitest
- **Schema DB** : 4 tables + vues + index conformes contrat 001
- **Performance** : WAL mode, requêtes préparées, pas de leaks mémoire
- **Architecture** : Séparation claire Repository → Data Access → Database

### 🔄 **TRANSITION JOURNAL #004**
Les fondations sont **solides et complètes**. Le prochain journal peut se concentrer sur :
- Pipeline d'ingestion MQTT → SQLite (modules prêts)
- Serveur HTTP (base et repository disponibles)
- Intégration complète des composants
