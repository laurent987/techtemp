# Journal #003 — Base SQLite + Config (2025-09-06)

## Objectif

Implémenter l'**infrastructure de données de base** pour le service-app :
- Configuration environment (via variables d'environnement)
- Initialisation SQLite avec schéma contractuel
- Repository pattern pour accès aux données
- Tests d'intégration SQLite

## Contexte

Journal #002 a livré le client MQTT robuste. Maintenant il faut la **fondation base de données** pour pouvoir stocker les lectures des capteurs selon le contrat 001.

## Décisions

- **SQLite** avec mode WAL activé pour les performances
- **better-sqlite3** comme driver (synchrone, performant)
- **Configuration via process.env** avec validation Joi
- **Migrations automatiques** au démarrage (fonction `migrateIfNeeded()`)
- **Architecture en couches** : Repository (métier) + Data Access (SQL) + Database (connexion)
- **Repository pattern correct** : logique métier sans SQL direct
- Tests avec **base temporaire** (`:memory:` ou fichier temp)

## Portée (Scope)

### ✅ À implémenter
- `src/config.js` : `loadConfig()` avec validation Joi des variables d'environnement
- `src/db/index.js` : 
  - `initDb(dbPath)` → ouvre connexion + WAL + foreign_keys  
  - `closeDb()` → fermeture propre
- `src/db/dataAccess.js` :
  - Couche d'accès aux données avec SQL spécifique
  - `insertDevice()`, `insertReading()`, `findLatestReading()`, etc.
- `src/repositories/deviceRepository.js` :
  - Logique métier pure (validation, transformation)
  - Délégation vers Data Access (pas de SQL direct)
- **Schéma SQLite** selon contrat 001 :
  - Tables : `rooms`, `devices`, `device_room_placements`, `readings_raw`
  - Vues : `v_room_last`
  - Index appropriés
- **Tests d'intégration** :
  - Configuration loading/validation
  - Database creation + schema migration
  - Repository avec mocks de Data Access
  - Data Access avec vraie base temporaire
  - Fermeture propre (pas de handles ouverts)

### ❌ Hors Portée
- Pipeline d'ingestion MQTT → DB (Journal #004)
- Serveur HTTP (Journal #005)
- API endpoints (Journal #006)
- Gestion des erreurs MQTT en production

## Plan d'implémentation

### Phase 1: Configuration
- [x] Écrire `test/config.test.js` avec cas de test :
  - Configuration valide avec toutes les variables
  - Variables manquantes → erreur explicite
  - Variables invalides → erreur avec détails
  - Valeurs par défaut (ex: `TOPIC_READING_PATTERN`)
- [x] Implémenter `loadConfig()` pour faire passer les tests
- [x] Validation Joi avec schéma détaillé

### Phase 2: Base SQLite
- [x] Écrire `test/db.test.js` avec cas de test :
  - Création base + schéma complet
  - Pragmas WAL + foreign_keys appliqués
  - Migration idempotente (relancer n'ajoute rien)
  - Fermeture propre sans leaks
- [x] Implémenter `initDb(dbPath)` et `closeDb()`
- [x] Implémenter le schéma selon contrat 001

### Phase 3: Data Access 
- [x] Écrire `test/dataAccess.test.js` avec cas de test :
  - CRUD operations sur chaque table
  - Contraintes de clés étrangères respectées
  - Requêtes complexes (jointures, agrégations)
  - Gestion d'erreurs SQL
- [x] Implémenter `createDataAccess(db)` avec méthodes SQL
- [x] Vérifier performance avec base temporaire

### Phase 4: Repository 
- [x] Écrire `test/repositories.test.js` avec cas de test :
  - Logique métier pure (validation, transformation)
  - Délégation correcte vers Data Access  
  - Gestion d'erreurs métier
  - Mocks de Data Access (pas de vraie DB)
- [x] Implémenter `createDeviceRepository(dataAccess)`
- [x] Tests d'intégration Repository + Data Access + DB

## Artifacts attendus

- `service-app/src/config.js` (implémentation complète)
- `service-app/src/db/index.js` (connexion + migrations)
- `service-app/src/db/dataAccess.js` (couche SQL)
- `service-app/src/repositories/deviceRepository.js` (logique métier)
- `service-app/test/config.test.js` (tests unitaires config)
- `service-app/test/db.test.js` (tests d'intégration DB)
- `service-app/test/repositories.test.js` (tests avec mocks)
- Mise à jour `package.json` si nouvelles dépendances

## Critères d'acceptation

✅ **Config** : `loadConfig()` parse et valide les variables d'environnement  
✅ **SQLite** : `initDb()` crée la base avec schéma complet et pragmas  
✅ **Data Access** : Couche SQL avec méthodes CRUD sur toutes les tables  
✅ **Repository** : Logique métier pure sans SQL direct  
✅ **Tests** : Tous les tests passent (71/71), pas de ressources qui fuient  
✅ **Contrat** : Schema DB conforme exactement au contrat 001  
✅ **Bonus** : Colonnes explicites (temperature/humidity) + Démos fonctionnelles  

## Commandes prévues

```bash
# Nouvelles dépendances
npm install better-sqlite3 joi

# Tests
npm run test -- db config

# Vérification schéma (manuel)
sqlite3 test.db ".schema"
```

## Liens utiles

- **Contrat 001** : `docs/contrats/001-base-service-app.md` (section 2 - SQLite)
- **Repository pattern** : logique métier séparée de l'accès données
- **Data Access Layer** : couche SQL spécialisée par type de base
- **better-sqlite3 docs** : https://github.com/WiseLibs/better-sqlite3
- **Joi validation** : https://joi.dev/api/

---

📝 **Architecture en couches** :
```
Business Logic → Repository (métier) → Data Access (SQL) → Database (connexion)
```

📝 **Next** : Journal #004 — Pipeline d'ingestion MQTT → SQLite

---

## 🎉 FINAL SUMMARY — Journal #003 COMPLETED (September 7, 2025)

### ✅ **STATUS: COMPLETE**
**71 tests passing** • **All phases completed** • **Objectives exceeded**

### 📊 **ACHIEVEMENTS**

**Phase 1 - Configuration** ✅
- `src/config.js`: Complete Joi validation with detailed schema
- `test/config.test.js`: 15 tests covering all error cases
- Support for optional variables (MQTT_USERNAME, MQTT_PASSWORD)
- Strict validation of ports and URLs

**Phase 2 - SQLite Database** ✅  
- `src/db/index.js`: Initialization with WAL + foreign_keys
- `test/db.test.js`: 8 integration tests for database + schema
- Complete schema according to contract 001 with **explicit columns**
- Idempotent migrations and proper cleanup

**Phase 3 - Data Access** ✅
- `src/db/dataAccess.js`: SQL layer with CRUD on all tables
- `test/dataAccess.test.js`: 8 tests with constraints and joins
- Optimized queries with preparation and reuse
- Robust SQL error handling

**Phase 4 - Repository** ✅
- `src/repositories/index.js`: Pure business logic without SQL
- `test/repositories.test.js`: 26 tests with business validation
- Correct Repository pattern with Data Access delegation
- Range validation (temperature -50°C/100°C, humidity 0%/100%)

### 🚀 **BONUS ACHIEVEMENTS**
- **Explicit columns**: `temperature`/`humidity` instead of `t`/`h` 
- **Functional demos**: Quick demo + Complete service with real MQTT
- **Organized database**: `examples/db-example/` (no root pollution)
- **Integrated exploration**: Database inspection directly in demo
- **MQTT tests**: 14 tests with integrated Aedes broker

### 📁 **DELIVERED ARTIFACTS**
```
service-app/
├── src/
│   ├── config.js                    ✅ (62 lines)
│   ├── db/
│   │   ├── index.js                 ✅ (134 lines) 
│   │   └── dataAccess.js            ✅ (140 lines)
│   └── repositories/
│       └── index.js                 ✅ (167 lines)
├── test/
│   ├── config.test.js               ✅ (15 tests)
│   ├── db.test.js                   ✅ (8 tests)  
│   ├── dataAccess.test.js           ✅ (8 tests)
│   ├── repositories.test.js         ✅ (26 tests)
│   └── mqtt.client.test.js          ✅ (14 tests)
└── examples/
    ├── quick-demo.js                ✅ Simple demo
    ├── service-complete-demo.js     ✅ Real MQTT demo
    └── db-example/                  ✅ Clean organization
```

### 💾 **TECHNICAL STATE**
- **71/71 tests** passing (100% success)
- **4 dependencies**: better-sqlite3, joi, mqtt, aedes/vitest
- **DB Schema**: 4 tables + views + indexes compliant with contract 001
- **Performance**: WAL mode, prepared queries, no memory leaks
- **Architecture**: Clear separation Repository → Data Access → Database

### 🔄 **TRANSITION TO JOURNAL #004**
The foundations are **solid and complete**. The next journal can focus on:
- MQTT → SQLite ingestion pipeline (modules ready)
- HTTP server (database and repository available)
- Complete component integration
